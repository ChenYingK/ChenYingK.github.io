<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/cat-logo.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/cat-logo.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/cat-logo.jpg">
  <link rel="mask-icon" href="/images/cat-logo.jpg" color="#222">






  
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;example.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Pisces&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta property="og:type" content="website">
<meta property="og:title" content="ykproton">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="ykproton">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="chenyk">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>ykproton</title>
  




  <noscript>
    
  </noscript>
<script>function loadCss(l){var d=document,h=d.head,s=d.createElement('link');s.rel='stylesheet';s.href=l;!function e(f){if (d.body)return f();setTimeout(function(){e(f)})}(function(){h.appendChild(s);});}loadCss('/style.css');loadCss('https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css');loadCss('https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css');</script><noscript><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css"></noscript></head>

<body itemscope="" itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ykproton</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">chenyk</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ykproton" title="GitHub → https://github.com/ykproton" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/12903.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/12903.html" class="post-title-link" itemprop="url">第二十三篇,Spring Boot之Quartz调度器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-04 13:02:00 / 修改时间：13:04:30" itemprop="dateCreated datePublished" datetime="2021-06-04T13:02:00+08:00">2021-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/12903.html" class="post-meta-item leancloud_visitors" data-flag-title="第二十三篇,Spring Boot之Quartz调度器" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="3-21-Quartz调度器-Quartz-Scheduler"><a href="#3-21-Quartz调度器-Quartz-Scheduler" class="headerlink" title="3.21 Quartz调度器 (Quartz Scheduler)"></a>3.21 Quartz调度器 (Quartz Scheduler)</h5><ol start="21">
<li><h5 id="Quartz调度器-Quartz-Scheduler"><a href="#Quartz调度器-Quartz-Scheduler" class="headerlink" title="Quartz调度器 (Quartz Scheduler)"></a>Quartz调度器 (Quartz Scheduler)</h5><p>Spring Boot 为使用 Quartz 调度程序提供了多种便利,包括 <code>spring-boot-starter-quartz</code> “Starter”.如果 Quartz 可用,则自动配置<code>Scheduler</code>(通过 <code>SchedulerFactoryBean</code> 抽象).</p>
<p>以下类型的 Bean 会被自动获取并与 <code>Scheduler</code> 关联:</p>
<ul>
<li><code>JobDetail</code>:定义特定Job. 可以使用 <code>JobBuilder</code> API 构建 <code>JobDetail</code> 实例.</li>
<li><code>Calendar</code></li>
<li><code>Trigger</code>:定义何时触发特定Job.</li>
</ul>
<p>默认情况下,使用内存中<code>JobStore</code>. 但是,如果 <code>DataSource</code> bean 在您的应用中可用并且相应地配置了 <code>spring.quartz.job-store-type</code> 属性,则可以配置基于 JDBC 的存储,如以下示例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.quartz.job-store-type</span>=<span class="string">jdbc</span></span><br></pre></td></tr></tbody></table></figure>

<p>使用 JDBC 存储时,可以在启动时初始化schema,如以下示例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.quartz.jdbc.initialize-schema</span>=<span class="string">always</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>警告:</p>
<p>​    默认情况下,使用 Quartz 库提供的标准脚本来检测和初始化数据库.这些脚本删除现有表,在每次重新启动时删除所有触发器. 也可以通过设置 <code>spring.quartz.jdbc.schema</code> 属性来提供自定义脚本.</p>
</blockquote>
<p>要让 Quartz 不使用应用程序主<code>DataSource</code>,而是指定的<code>DataSource</code>,声明一个 <code>DataSource</code> bean,使用 <code>@QuartzDataSource</code> 标注其 <code>@Bean</code> 方法.这样做可以让Quartz专用的DataSource同时被 <code>SchedulerFactoryBean</code>使用和初始化schema.类似地,要让 Quartz 使用非应用程序主 <code>TransactionManager</code> 之外的 <code>TransactionManager</code>, 声明一个 <code>TransactionManager</code> bean,使用 <code>@QuartzTransactionManager</code> 标注其 <code>@Bean</code> 方法.</p>
<p>默认情况下,配置创建的jobs不会覆盖,从持久job 存储中读取的已注册作业.要启用覆盖现有job,设置 <code>spring.quartz.overwrite-existing-jobs</code> 属性.</p>
<p>Quartz Scheduler 配置可以使用 <code>spring.quartz</code> 属性和 <code>SchedulerFactoryBeanCustomizer</code> bean 进行自定义,这允许以编程的形式来自定义<code>SchedulerFactoryBean</code>.可以使用 <code>spring.quartz.properties.*</code> 自定义Quartz的高级配置.</p>
<blockquote>
<p>注意:</p>
<p>​    特别是,<code>Executor</code> bean 与<code>scheduler</code>无关,因为 Quartz 提供了一种通过 <code>spring.quartz.properties</code> 配置scheduler的方法.如果需要自定义任务executor,可以考虑实现<code>SchedulerFactoryBeanCustomizer</code>.</p>
</blockquote>
<p>Jobs可以定义 setter 来注入数据映射属性. 也可以用类似的方式注入普通 bean,如下例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySampleJob</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fields ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inject "MyService" bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyService</span><span class="params">(MyService myService)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.myService = myService;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inject the "name" job data property</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>{</span><br><span class="line">        <span class="keyword">this</span>.myService.someMethod(context.getFireTime(), <span class="keyword">this</span>.name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/53415.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/53415.html" class="post-title-link" itemprop="url">第二十四篇,Spring Boot之任务执行与调度</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-04 13:02:00 / 修改时间：13:04:06" itemprop="dateCreated datePublished" datetime="2021-06-04T13:02:00+08:00">2021-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/53415.html" class="post-meta-item leancloud_visitors" data-flag-title="第二十四篇,Spring Boot之任务执行与调度" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="3-22-任务执行与调度-Task-Execution-and-Scheduling"><a href="#3-22-任务执行与调度-Task-Execution-and-Scheduling" class="headerlink" title="3.22 任务执行与调度 (Task Execution and Scheduling)"></a>3.22 任务执行与调度 (Task Execution and Scheduling)</h5><ol start="22">
<li><h5 id="任务执行与调度-Task-Execution-and-Scheduling"><a href="#任务执行与调度-Task-Execution-and-Scheduling" class="headerlink" title="任务执行与调度 (Task Execution and Scheduling)"></a>任务执行与调度 (Task Execution and Scheduling)</h5><p>在context中没有 <code>Executor</code> bean 的情况下,Spring Boot 自动配置了一个具有合理默认值的 <code>ThreadPoolTaskExecutor</code>,可以自动关联到异步任务执行(<code>@EnableAsync</code>)和 Spring MVC 异步请求处理.</p>
<blockquote>
<p>建议:</p>
<p>​    如果在context中添加了自定义的 <code>Executor</code>,常规任务执行(即<code>@EnableAsync</code>)将透明地使用它,但不会配置对 Spring MVC 支持,因为它需要 <code>AsyncTaskExecutor</code> 实现(名为 <code>applicationTaskExecutor</code>).根据的目标安排,可以将 <code>Executor</code> 更改为 <code>ThreadPoolTaskExecutor</code> 或同时定义 <code>ThreadPoolTaskExecutor </code>和 <code>AsyncConfigurer</code> 包装自定义的 <code>Executor</code>.</p>
<p>自动配置的 <code>TaskExecutorBuilder</code> 允许开发者轻松创建实例, 也是重现默认情况下自动配置所做的事情.</p>
</blockquote>
<p>线程池使用8个核心线程,可以根据负载增减. 这些默认设置可以使用 <code>spring.task.execution</code> 命名空间进行调整,如以下示例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.task.execution.pool.max-size</span>=<span class="string">16</span></span><br><span class="line"><span class="meta">spring.task.execution.pool.queue-capacity</span>=<span class="string">100</span></span><br><span class="line"><span class="meta">spring.task.execution.pool.keep-alive</span>=<span class="string">10s</span></span><br></pre></td></tr></tbody></table></figure>

<p>这会将线程池更改为使用有界队列,以便当队列已满(100 个任务)时,线程池增加到最多 16 个线程.池的收缩更加积极,如果线程空闲 10 秒(而不是默认情况下为 60 秒),将被回收.</p>
<p>如果需要与计划任务执行相关联(例如 <code>@EnableScheduling</code>),也可以自动配置 <code>ThreadPoolTaskScheduler</code>. 线程池默认使用一个线程,其设置可以使用 <code>spring.task.scheduling</code> 命名空间进行微调,如下例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.task.scheduling.thread-name-prefix</span>=<span class="string">scheduling-</span></span><br><span class="line"><span class="meta">spring.task.scheduling.pool.size</span>=<span class="string">2</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果需要创建自定义executor或scheduler,则 <code>TaskExecutorBuilder</code> bean 和 <code>TaskSchedulerBuilder</code> bean 在context中都可用.</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/55600.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/55600.html" class="post-title-link" itemprop="url">第二十二篇,Spring Boot之Hazelcast</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-04 13:01:00 / 修改时间：13:04:46" itemprop="dateCreated datePublished" datetime="2021-06-04T13:01:00+08:00">2021-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/55600.html" class="post-meta-item leancloud_visitors" data-flag-title="第二十二篇,Spring Boot之Hazelcast" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>861</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="3-20-Hazelcast"><a href="#3-20-Hazelcast" class="headerlink" title="3.20 Hazelcast"></a>3.20 Hazelcast</h5><ol start="20">
<li><h5 id="Hazelcast"><a href="#Hazelcast" class="headerlink" title="Hazelcast"></a>Hazelcast</h5><p>如果 Hazelcast 在classpath上并且找到了合适的配置,Spring Boot 会自动配置一个 <code>HazelcastInstance</code>,可以将它注入到应用中.</p>
<p>Spring Boot 首先尝试检查以下配置选项来创建客户端:</p>
<ul>
<li><code>com.hazelcast.client.config.ClientConfig</code> bean 的存在.</li>
<li><code>spring.hazelcast.config</code> 属性定义的配置文件</li>
<li><code>hazelcast.client.config</code> 系统属性的存在.</li>
<li>工作目录或classpath根目录中的 <code>hazelcast-client.xml</code>.</li>
<li>工作目录或classpath根目录中的 <code>hazelcast-client.yaml</code>.</li>
</ul>
<blockquote>
<p>注意:</p>
<p>​    Spring Boot 支持 Hazelcast 4 和 Hazelcast 3.如果你降级到 Hazelcast 3,应该将 <code>hazelcast-client</code> 添加到classpath中来配置客户端.</p>
</blockquote>
<p>如果无法创建客户端,Spring Boot 会尝试配置嵌入式服务器.如果定义了一个 <code>com.hazelcast.config.Config</code> bean,Spring Boot 会使用它.如果配置定义了一个实例名称,Spring Boot 会尝试定位现有实例而不是创建新实例.</p>
<p>还可以通过配置指定 Hazelcast 配置文件,如以下示例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.hazelcast.config</span>=<span class="string">classpath:config/my-hazelcast.xml</span></span><br></pre></td></tr></tbody></table></figure>

<p>否则,Spring Boot 会尝试从默认位置查找 Hazelcast 配置:工作目录或classpath根目录中的 <code>hazelcast.xml</code>,或相同位置的<code>.yaml</code>对应文件.还检查是否设置了 <code>hazelcast.config</code> 系统属性. 有关更多详细信息,请参阅 <a target="_blank" rel="noopener" href="https://docs.hazelcast.org/docs/latest/manual/html-single/">Hazelcast documentation</a>.</p>
<blockquote>
<p>注意:</p>
<p>​    Spring Boot 也对 Hazelcast 有显式的缓存支持. 如果启用缓存,<code>HazelcastInstance</code>会自动包装在 <code>CacheManager</code> 实现中.</p>
</blockquote>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/16277.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/16277.html" class="post-title-link" itemprop="url">第二十一篇,Spring Boot之使用 JTA 的分布式事务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-04 13:00:00 / 修改时间：13:00:33" itemprop="dateCreated datePublished" datetime="2021-06-04T13:00:00+08:00">2021-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/16277.html" class="post-meta-item leancloud_visitors" data-flag-title="第二十一篇,Spring Boot之使用 JTA 的分布式事务" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="3-19-使用-JTA-的分布式事务-Distributed-Transactions-with-JTA"><a href="#3-19-使用-JTA-的分布式事务-Distributed-Transactions-with-JTA" class="headerlink" title="3.19 使用 JTA 的分布式事务(Distributed Transactions with JTA)"></a>3.19 使用 JTA 的分布式事务(Distributed Transactions with JTA)</h5><ol start="19">
<li><h6 id="使用-JTA-的分布式事务-Distributed-Transactions-with-JTA"><a href="#使用-JTA-的分布式事务-Distributed-Transactions-with-JTA" class="headerlink" title="使用 JTA 的分布式事务(Distributed Transactions with JTA)"></a>使用 JTA 的分布式事务(Distributed Transactions with JTA)</h6><p>Spring Boot 通过使用 Atomikos 嵌入式事务管理器支持跨多个 XA 资源的分布式 JTA 事务.部署到合适的 Java EE 应用服务器时, JTA 事务也受支持.</p>
<p>当检测到 JTA 环境时,Spring 的<code> JtaTransactionManager</code> 将用于管理事务.自动配置的 JMS,数据源和 JPA bean 会被升级以支持 XA 事务.可以使用标准的 Spring 习惯用法,例如 <code>@Transactional</code>,来参与分布式事务. 如果在 JTA 环境中并且仍想使用本地事务,则可以将 <code>spring.jta.enabled</code> 属性设置为 <code>false</code> 以禁用 JTA 自动配置.</p>
<ol>
<li><h6 id="使用Atomikos事务管理器-Using-an-Atomikos-Transaction-Manager"><a href="#使用Atomikos事务管理器-Using-an-Atomikos-Transaction-Manager" class="headerlink" title="使用Atomikos事务管理器(Using an Atomikos Transaction Manager)"></a>使用Atomikos事务管理器(Using an Atomikos Transaction Manager)</h6><p>Atomikos 是一个流行的开源事务管理器,可以嵌入到 Spring Boot 应用程序中.可以使用 <code>spring-boot-starter-jta-atomikos</code> starter来拉取 Atomikos 库.Spring Boot 自动配置 Atomikos 并将适当的<code>depends-on</code>应用于 Spring bean 以实现正确的启动和关闭顺序.</p>
<p>默认情况下,Atomikos 事务日志被写入应用主目录(应用程序 jar 文件所在的目录)中的<code>transaction-logs</code>目录.可以通过在 <code>application.properties</code> 文件中设置 <code>spring.jta.log-dir</code> 属性来自定义此目录的位置.以 <code>spring.jta.atomikos.properties</code> 开头的属性也可用于自定义 Atomikos <code>UserTransactionServiceImp</code>.有关完整的详细信息,请参阅 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/api/org/springframework/boot/jta/atomikos/AtomikosProperties.html"><code>AtomikosProperties</code> Javadoc</a> .</p>
<blockquote>
<p>注意:</p>
<p>​    为了保证多个事务管理器可以安全地协调同一个资源管理器,每个 Atomikos 实例必须配置一个唯一的 ID.默认情况下,此 ID 是运行 Atomikos 的机器的 IP 地址.为了保证生产环境中的唯一性,应该为应用程序的每个实例配置 <code>spring.jta.transaction-manager-id</code> 属性配置不同的值.</p>
</blockquote>
</li>
<li><h6 id="使用-Java-EE-托管事务管理器-Using-a-Java-EE-Managed-Transaction-Manager"><a href="#使用-Java-EE-托管事务管理器-Using-a-Java-EE-Managed-Transaction-Manager" class="headerlink" title="使用 Java EE 托管事务管理器 (Using a Java EE Managed Transaction Manager)"></a>使用 Java EE 托管事务管理器 (Using a Java EE Managed Transaction Manager)</h6><p>如果将 Spring Boot 应用打包为 <code>war</code> 或 <code>ear</code> 文件并将其部署到 Java EE 应用服务器,则可以使用应用服务器的内置事务管理器.Spring Boot 尝试通过查看常见的 JNDI 位置(<code>java:comp/UserTransaction</code>,<code>java:comp/TransactionManager</code> 等)来自动配置事务管理器.如果使用应用服务器提供的事务服务,通常还希望确保所有资源都由服务器管理并通过 JNDI 公开.Spring Boot 尝试通过在 JNDI 路径(<code>java:/JmsXA</code> 或 <code>java:/XAConnectionFactory</code>)中查找 <code>ConnectionFactory</code> 来自动配置 JMS,可以使用 <code>spring.datasource.jndi-name</code> 属性来配置数据源.</p>
</li>
<li><h6 id="混合-XA-和非-XA-JMS-连接"><a href="#混合-XA-和非-XA-JMS-连接" class="headerlink" title="混合 XA 和非 XA JMS 连接"></a>混合 XA 和非 XA JMS 连接</h6><p>使用 JTA 时,主要的 JMS <code>ConnectionFactory</code> bean 是 XA-aware 并参与分布式事务.可以注入到 bean 中,而无需使用任何 <code>@Qualifier</code>.</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在某些情况下,可能希望使用非 XA的<code>ConnectionFactory</code> 来处理一些 JMS 消息.例如, JMS 处理逻辑可能需要时间比 XA 超时时间更长.</p>
<p>如果要使用非 XA <code>ConnectionFactory</code>,可以使用 <code>nonXaJmsConnectionFactory</code> bean:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(<span class="meta">@Qualifier("nonXaJmsConnectionFactory")</span> ConnectionFactory connectionFactory)</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>为了一致性, <code>jmsConnectionFactory</code> bean还被使用 bean 别名 <code>xaJmsConnectionFactory </code>提供.</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(<span class="meta">@Qualifier("xaJmsConnectionFactory")</span> ConnectionFactory connectionFactory)</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="支持替代嵌入式事务管理器-Supporting-an-Alternative-Embedded-Transaction-Manager"><a href="#支持替代嵌入式事务管理器-Supporting-an-Alternative-Embedded-Transaction-Manager" class="headerlink" title="支持替代嵌入式事务管理器 (Supporting an Alternative Embedded Transaction Manager)"></a>支持替代嵌入式事务管理器 (Supporting an Alternative Embedded Transaction Manager)</h6><p><code>XAConnectionFactoryWrapper</code> 和 <code>XADataSourceWrapper</code> 接口可用于支持替代的嵌入式事务管理器.接口负责包装 <code>XAConnectionFactory</code> 和 <code>XADataSource</code> bean 并将它们公开为常规的<code>ConnectionFactory</code> 和 <code>DataSource</code> bean,它们透明地注册到分布式事务中.数据源和 JMS 自动配置使用 JTA 变体,前提是在 <code>ApplicationContext</code> 中注册了 <code>JtaTransactionManager</code> bean 和适当的 XA 包装 bean.</p>
<p> <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jta/atomikos/AtomikosXAConnectionFactoryWrapper.java">AtomikosXAConnectionFactoryWrapper</a> 和 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jta/atomikos/AtomikosXADataSourceWrapper.java">AtomikosXADataSourceWrapper</a> 提供了如何编写 XA 包装器的例子.</p>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/34767.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/34767.html" class="post-title-link" itemprop="url">第二十篇,Spring Boot之发送邮件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-04 12:58:00 / 修改时间：13:05:10" itemprop="dateCreated datePublished" datetime="2021-06-04T12:58:00+08:00">2021-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/34767.html" class="post-meta-item leancloud_visitors" data-flag-title="第二十篇,Spring Boot之发送邮件" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>646</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="3-18-发送邮件-Sending-Email"><a href="#3-18-发送邮件-Sending-Email" class="headerlink" title="3.18 发送邮件 (Sending Email)"></a>3.18 发送邮件 (Sending Email)</h5><ol start="18">
<li><h5 id="发送邮件-Sending-Email"><a href="#发送邮件-Sending-Email" class="headerlink" title="发送邮件 (Sending Email)"></a>发送邮件 (Sending Email)</h5><p>Spring Framework 提供了使用 <code>JavaMailSender</code> 接口发送电子邮件的抽象,Spring Boot 为其提供了自动配置以及 starter 模块.</p>
<blockquote>
<p>建议:</p>
<p>​    有关如何使用 JavaMailSender 的详细说明,请参阅参考文档(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/integration.html#mail">reference documentation</a>).</p>
</blockquote>
<p>如果 <code>spring.mail.host</code> 和相关库(由 <code>spring-boot-starter-mail</code> 定义)可用,如果<code>JavaMailSender</code>不存在,则会创建默认的 <code>JavaMailSender</code>.可以通过 <code>spring.mail</code> 命名空间中的配置项进一步自定义sender . 有关更多详细信息,参阅 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/mail/MailProperties.java"><code>MailProperties</code></a>.</p>
<p>特别是,某些默认超时值是无限的,可能希望更改该值以避免线程被无响应的邮件服务器所阻塞,如下例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.mail.properties[mail.smtp.connectiontimeout]</span>=<span class="string">5000</span></span><br><span class="line"><span class="meta">spring.mail.properties[mail.smtp.timeout]</span>=<span class="string">3000</span></span><br><span class="line"><span class="meta">spring.mail.properties[mail.smtp.writetimeout]</span>=<span class="string">5000</span></span><br></pre></td></tr></tbody></table></figure>

<p>还可以使用来自 JNDI 的现有<code>Session</code>配置 <code>JavaMailSender</code>:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.mail.jndi-name</span>=<span class="string">mail/Session</span></span><br></pre></td></tr></tbody></table></figure>

<p>设置 <code>jndi-name</code> 时,它优先于所有其他与会话相关的设置.</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/45647.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/45647.html" class="post-title-link" itemprop="url">第十九篇,Spring Boot之校验</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-04 12:57:00 / 修改时间：13:05:24" itemprop="dateCreated datePublished" datetime="2021-06-04T12:57:00+08:00">2021-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/45647.html" class="post-meta-item leancloud_visitors" data-flag-title="第十九篇,Spring Boot之校验" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>392</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="3-17-校验-Validation"><a href="#3-17-校验-Validation" class="headerlink" title="3.17 校验(Validation)"></a>3.17 校验(Validation)</h5><ol start="17">
<li><h6 id="校验-Validation"><a href="#校验-Validation" class="headerlink" title="校验(Validation)"></a>校验(Validation)</h6><p>只要 JSR-303 实现(例如 Hibernate 验证器)在classpath上,Bean Validation 1.1 支持的方法验证功能就会自动启用.这让 bean 方法可以使用 <code>javax.validation</code> 注解对其参数和/或返回值的进行约束.带有这种注解标注的方法的目标类需要在类型级别使用 <code>@Validated</code> 注解进行标注,以便在类内方法中搜索内联约束注解.</p>
<p>例如,以下服务触发第一个参数的验证,确保其大小在 8 到 10 之间:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Archive <span class="title">findByCodeAndAuthor</span><span class="params">(<span class="meta">@Size(min = 8, max = 10)</span> String code, Author author)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/64077.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/64077.html" class="post-title-link" itemprop="url">第十八篇,Spring Boot之使用 WebClient 调用 REST 服务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-04 12:56:00 / 修改时间：13:05:42" itemprop="dateCreated datePublished" datetime="2021-06-04T12:56:00+08:00">2021-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/64077.html" class="post-meta-item leancloud_visitors" data-flag-title="第十八篇,Spring Boot之使用 WebClient 调用 REST 服务" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="3-16-使用-WebClient-调用-REST-服务-Calling-REST-Services-with-WebClient"><a href="#3-16-使用-WebClient-调用-REST-服务-Calling-REST-Services-with-WebClient" class="headerlink" title="3.16 使用 WebClient 调用 REST 服务 (Calling REST Services with WebClient)"></a>3.16 使用 WebClient 调用 REST 服务 (Calling REST Services with WebClient)</h5><ol start="16">
<li><h6 id="使用-WebClient-调用-REST-服务-Calling-REST-Services-with-WebClient"><a href="#使用-WebClient-调用-REST-服务-Calling-REST-Services-with-WebClient" class="headerlink" title="使用 WebClient 调用 REST 服务 (Calling REST Services with WebClient)"></a>使用 WebClient 调用 REST 服务 (Calling REST Services with WebClient)</h6><p>如果classpath上有 Spring WebFlux,也可以选择使用 <code>WebClient</code> 来调用远程 REST 服务.与 <code>RestTemplate</code> 相比,这个客户端更加函数式,并且是完全响应式的.可以在 Spring Framework 文档的专门部分中了解有关 WebClient 的更多信息.</p>
<p>Spring Boot 为创建并预配置了一个 <code>WebClient.Builder</code>. 强烈建议将其注入到组件中并使用它来创建 <code>WebClient</code> 实例.Spring Boot 正在配置该构建器以共享 HTTP 资源,以与服务器相同的方式反映编解码器设置(请参阅 WebFlux HTTP 编解码器自动配置 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.developing-web-applications.spring-webflux.httpcodecs">WebFlux HTTP codecs auto-configuration</a>)等等.</p>
<p>以下代码显示了一个典型示例:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebClient webClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(WebClient.Builder webClientBuilder)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.webClient = webClientBuilder.baseUrl(<span class="string">"https://example.org"</span>).build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Details&gt; <span class="title">someRestCall</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.webClient.get().uri(<span class="string">"/{name}/details"</span>, name).retrieve().bodyToMono(Details.class);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><h6 id="WebClient-运行时-WebClient-Runtime"><a href="#WebClient-运行时-WebClient-Runtime" class="headerlink" title="WebClient 运行时 (WebClient Runtime)"></a>WebClient 运行时 (WebClient Runtime)</h6><p>Spring Boot 将自动检测使用哪个 <code>ClientHttpConnector</code> 来驱动 <code>WebClient</code>,具体取决于应用程序classpath上可用的库.目前,支持 Reactor Netty 和 Jetty RS 客户端.<code>spring-boot-starter-webflux</code> “starter” 默认依赖于 <code>io.projectreactor.netty:reactor-netty</code>,它带来了服务端和客户端的实现.如果您选择使用 Jetty 作为响应式服务器,则应添加对 Jetty Reactive HTTP 客户端库的依赖 <code>org.eclipse.jetty:jetty-reactive-httpclient</code>.服务器和客户端使用相同的技术有其优势,因为它会自动在客户端和服务器之间共享 HTTP 资源.</p>
<p>开发人员可以通过提供自定义的 <code>ReactorResourceFactory</code> 或 <code>JettyResourceFactory</code> bean 来覆盖 Jetty 和 Reactor Netty 的资源配置 - 这将应用于客户端和服务器.</p>
<p>如果希望覆盖客户端该选择,可以定义自己的 <code>ClientHttpConnector</code> bean 并完全控制客户端配置.</p>
<p>可以在 Spring Framework 参考文档中了解有关 <code>WebClient</code> 配置选项的更多信息(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/web-reactive.html#webflux-client-builder"><code>WebClient</code> configuration options in the Spring Framework reference documentation</a>).</p>
</li>
<li><h6 id="自定义WebClient-WebClient-Customization"><a href="#自定义WebClient-WebClient-Customization" class="headerlink" title="自定义WebClient (WebClient Customization)"></a>自定义WebClient (WebClient Customization)</h6><p> 自定义<code>WebClient</code>有三种方法,具体取决于希望自定义应用的范围.</p>
<p>为了尽可能缩小任何自定义的范围,注入自动配置的 <code>WebClient.Builder</code>,然后根据需要调用其方法.<code>WebClient.Builder</code> 实例是有状态的:Builder上的任何更改都会反映在随后使用它创建的所有客户端中.如果想用同一个构建器创建多个客户端,也可以考虑使用 <code>WebClient.Builder other = builder.clone();</code> 克隆构建器.</p>
<p>要对所有 <code>WebClient.Builder</code> 实例进行应用范围的,额外的自定义,可以声明 <code>WebClientCustomizer</code> bean 并在注入点本地更改 <code>WebClient.Builder</code>.</p>
<p>最后,可以回退到原始 API, 使用 <code>WebClient.create()</code>. 在这种情况下,不会应用自动配置或 <code>WebClientCustomizer</code>.</p>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/54638.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/54638.html" class="post-title-link" itemprop="url">第十七篇,Spring Boot之使用 RestTemplate 调用 REST 服务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-04 12:55:00 / 修改时间：13:05:58" itemprop="dateCreated datePublished" datetime="2021-06-04T12:55:00+08:00">2021-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/54638.html" class="post-meta-item leancloud_visitors" data-flag-title="第十七篇,Spring Boot之使用 RestTemplate 调用 REST 服务" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="3-15-使用-RestTemplate-调用-REST-服务"><a href="#3-15-使用-RestTemplate-调用-REST-服务" class="headerlink" title="3.15 使用 RestTemplate 调用 REST 服务"></a>3.15 使用 RestTemplate 调用 REST 服务</h5><ol start="15">
<li><h5 id="使用-RestTemplate-调用-REST-服务-Calling-REST-Services-with-RestTemplate"><a href="#使用-RestTemplate-调用-REST-服务-Calling-REST-Services-with-RestTemplate" class="headerlink" title="使用 RestTemplate 调用 REST 服务(Calling REST Services with RestTemplate)"></a>使用 RestTemplate 调用 REST 服务(Calling REST Services with RestTemplate)</h5><p>如果需要从应用中调用远程 REST 服务,可以使用 Spring Framework 的 <code>RestTemplate</code> 类.由于 <code>RestTemplate</code> 实例在使用前经常需要自定义,因此 Spring Boot 没有提供任何单个自动配置的 <code>RestTemplate</code> bean.然而,它会自动配置一个 <code>RestTemplateBuilder</code>,它可以在需要时用于创建 <code>RestTemplate</code> 实例.自动配置的 <code>RestTemplateBuilder</code> 确保将合适的 <code>HttpMessageConverters</code>应用于 <code>RestTemplate</code> 实例.</p>
<p>以下代码显示了一个典型示例:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(RestTemplateBuilder restTemplateBuilder)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplateBuilder.build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Details <span class="title">someRestCall</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"/{name}/details"</span>, Details.class, name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    <code>RestTemplateBuilder</code> 包含许多有用的方法,可用于快速配置 <code>RestTemplate</code>.例如,要添加 BASIC 身份验证支持,您可以使用 <code>builder.basicAuthentication("user", "password").build()</code>.</p>
</blockquote>
<ol>
<li><h6 id="自定义RestTemplate-RestTemplate-Customization"><a href="#自定义RestTemplate-RestTemplate-Customization" class="headerlink" title="自定义RestTemplate (RestTemplate Customization)"></a>自定义RestTemplate (RestTemplate Customization)</h6><p>自定义<code>RestTemplate</code> 有三种主要方法,具体取决于自定义应用的范围.</p>
<p>为了尽可能缩小任何自定义的范围,注入自动配置的 <code>RestTemplateBuilder</code>,然后根据需要调用其方法.每个方法调用都会返回一个新的 <code>RestTemplateBuilder</code> 实例,因此自定义值影响构建器的使用.</p>
<p>要进行应用范围上的的,额外的自定义,使用 <code>RestTemplateCustomizer</code> bean.所有这些 bean 都会自动注册到自动配置的 <code>RestTemplateBuilder</code> 并应用于使用它构建的任何模板.</p>
<p>以下示例显示了一个定制器,它为除 <code>192.168.0.5</code> 之外的所有主机配置代理的使用:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestTemplateCustomizer</span> <span class="keyword">implements</span> <span class="title">RestTemplateCustomizer</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(RestTemplate restTemplate)</span> </span>{</span><br><span class="line">        HttpRoutePlanner routePlanner = <span class="keyword">new</span> CustomRoutePlanner(<span class="keyword">new</span> HttpHost(<span class="string">"proxy.example.com"</span>));</span><br><span class="line">        HttpClient httpClient = HttpClientBuilder.create().setRoutePlanner(routePlanner).build();</span><br><span class="line">        restTemplate.setRequestFactory(<span class="keyword">new</span> HttpComponentsClientHttpRequestFactory(httpClient));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRoutePlanner</span> <span class="keyword">extends</span> <span class="title">DefaultProxyRoutePlanner</span> </span>{</span><br><span class="line"></span><br><span class="line">        CustomRoutePlanner(HttpHost proxy) {</span><br><span class="line">            <span class="keyword">super</span>(proxy);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> HttpHost <span class="title">determineProxy</span><span class="params">(HttpHost target, HttpRequest request, HttpContext context)</span> <span class="keyword">throws</span> HttpException </span>{</span><br><span class="line">            <span class="keyword">if</span> (target.getHostName().equals(<span class="string">"192.168.0.5"</span>)) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.determineProxy(target, request, context);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后,还可以创建自己的 <code>RestTemplateBuilder</code> bean.为了防止关闭 <code>RestTemplateBuilder </code>的自动配置,并防止使用任何 <code>RestTemplateCustomizer</code> bean,确保使用 <code>RestTemplateBuilderConfigurer</code> 配置自定义实例.下面的示例公开了一个Spring Boot 自动配置的 <code>RestTemplateBuilder</code>,还指定了自定义连接和读取超时:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestTemplateBuilderConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplateBuilder <span class="title">restTemplateBuilder</span><span class="params">(RestTemplateBuilderConfigurer configurer)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> configurer.configure(<span class="keyword">new</span> RestTemplateBuilder()).setConnectTimeout(Duration.ofSeconds(<span class="number">5</span>))</span><br><span class="line">                .setReadTimeout(Duration.ofSeconds(<span class="number">2</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最极端(也很少使用)的选项是在不使用配置器,创建自己的 <code>RestTemplateBuilder</code> bean.这样做会关闭 <code>RestTemplateBuilder</code> 的自动配置并禁用任何的 <code>RestTemplateCustomizer</code> bean.</p>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/10287.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/10287.html" class="post-title-link" itemprop="url">第十六篇,Spring Boot之Message</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-04 12:52:00 / 修改时间：12:54:55" itemprop="dateCreated datePublished" datetime="2021-06-04T12:52:00+08:00">2021-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/10287.html" class="post-meta-item leancloud_visitors" data-flag-title="第十六篇,Spring Boot之Message" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h6 id="3-14-Messaging-消息中间件"><a href="#3-14-Messaging-消息中间件" class="headerlink" title="3.14 Messaging(消息中间件)"></a>3.14 Messaging(消息中间件)</h6><ol start="14">
<li><h6 id="Messaging-消息中间件"><a href="#Messaging-消息中间件" class="headerlink" title="Messaging(消息中间件)"></a>Messaging(消息中间件)</h6><p>Spring Framework 对集成消息中间件系统提供了大量支持,从使用<code>JmsTemplate</code>的 JMS API 的简单使用到异步接收消息的完整基础架构.Spring AMQP 为高级消息队列协议提供了类似的功能集.Spring Boot 还为 <code>RabbitTemplate</code> 和 RabbitMQ 提供了自动配置选项.Spring WebSocket 本身就包含对 STOMP 消息传递的支持,而 Spring Boot 通过starter和少量自动配置来实现支持.Spring Boot 还支持 Apache Kafka.</p>
<ol>
<li><h6 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h6><p><code>javax.jms.ConnectionFactory</code>接口提供了创建 <code>javax.jms.Connection</code> ,以用于 JMS broker交互的标准方法. 虽然Spring需要一个 <code>ConnectionFactory</code> 来与 JMS 一起工作,但通常不需要自己直接使用,而是可以依靠更高级别的消息传递抽象.(有关详细信息<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/integration.html#jms">relevant section</a>,请参阅 Spring Framework 参考文档的相关部分).Spring Boot 还自动配置必要的infrastructure 来发送和接收消息.</p>
<ol>
<li><h6 id="ActiveMQ-Support"><a href="#ActiveMQ-Support" class="headerlink" title="ActiveMQ Support"></a>ActiveMQ Support</h6><p>当classpath上有 ActiveMQ 时,Spring Boot 也可以配置 <code>ConnectionFactory</code>.如果代理存在,则会自动启动和配置嵌入式代理(前提是没有通过配置指定代理 URL).</p>
<blockquote>
<p>注意:</p>
<p>​    如果使用<code>spring-boot-starter-activemq</code>,则提供了连接或嵌入 ActiveMQ 实例所需的依赖项,以及和JMS集成的 Spring infrastructure.</p>
</blockquote>
<p>可以使用<code>spring.activemq.*</code>中的外部配置属性来配置 ActiveMQ.例如,可以在 <code>application.properties</code> 中声明以下部分:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.activemq.broker-url</span>=<span class="string">tcp://192.168.1.210:9876</span></span><br><span class="line"><span class="meta">spring.activemq.user</span>=<span class="string">admin </span></span><br><span class="line"><span class="meta">spring.activemq.password</span>=<span class="string">secret</span></span><br></pre></td></tr></tbody></table></figure>

<p>默认情况下, <code>CachingConnectionFactory</code>使用合理的设置包装本地 <code>ConnectionFactory</code>,可以通过 <code>spring.jms.*</code> 中的外部配置属性来配置这些设置:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.jms.cache.session-cache-size</span>=<span class="string">5</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果更想要使用本地池,可以添加依赖<code>org.messaginghub:pooled-jms</code> ,并相应地配置 <code>JmsPoolConnectionFactory</code> 来实现,如下例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.activemq.pool.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.activemq.pool.max-connections</span>=<span class="string">50</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    有关更多支持的选项,参阅(<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/activemq/ActiveMQProperties.java"><code>ActiveMQProperties</code></a>).可以注册任意数量的实现 <code>ActiveMQConnectionFactoryCustomizer</code> 的 bean 以进行更高级的自定义.</p>
</blockquote>
<p>默认情况下,如果目标尚不存在,ActiveMQ 会创建一个目标,以便根据名称解析目标.</p>
</li>
<li><h6 id="ActiveMQ-Artemis-Support-支持ActiveMQ-Artemis"><a href="#ActiveMQ-Artemis-Support-支持ActiveMQ-Artemis" class="headerlink" title="ActiveMQ Artemis Support (支持ActiveMQ Artemis)"></a>ActiveMQ Artemis Support (支持ActiveMQ Artemis)</h6><p>Spring Boot检测到ActiveMQ Artemis在classpath上可用时,自动配置 <code>ConnectionFactory</code>. 如果broker存在,则会自动启动和配置嵌入式broker(除非已显式设置模式属性).支持的模式是<code>embedded</code>(明确表明需要一个嵌入式代理,如果代理在类路径上不可用,则会发生错误)和<code>native</code>(使用 netty 传输协议连接到代理).配置后者时,Spring Boot 会配置一个 <code>ConnectionFactory</code>,它使用默认设置连接到在本地机器上运行的broker.</p>
<blockquote>
<p>注意:</p>
<p>​    如果使用 <code>spring-boot-starter-artemis</code>,则提供连接到ActiveMQ Artemis 实例所需的依赖,以及与 JMS 集成的 Spring infrastructure.将 <code>org.apache.activemq:artemis-jms-server</code> 添加到的应用中,可以使用嵌入模式.</p>
</blockquote>
<p>ActiveMQ Artemis 配置由 <code>spring.artemis.*</code> 中的外部配置属性控制. 例如,可以在 <code>application.properties</code> 中声明以下部分:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.artemis.mode</span>=<span class="string">native</span></span><br><span class="line"><span class="meta">spring.artemis.broker-url</span>=<span class="string">tcp://192.168.1.210:9876</span></span><br><span class="line"><span class="meta">spring.artemis.user</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.artemis.password</span>=<span class="string">secret</span></span><br></pre></td></tr></tbody></table></figure>

<p>嵌入broker时,可以选择是否要启用持久化并列出应该可用的destination.这些可以使用逗号分割的列表来指定,从而使用默认选项创建它们,或者可以定义 <code>org.apache.activemq.artemis.jms.server.config.JMSQueueConfiguration</code> 或 <code>org.apache.activemq.artemis.jms.server.config.TopicConfiguration</code>类型的bean,分别用于queue和configurations高级配置.</p>
<p>默认情况下, <code>CachingConnectionFactory</code> 使用合理的设置包装本地的<code>ConnectionFactory</code>,您可以通过 <code>spring.jms.*</code> 中的外部配置属性控制这些设置:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.jms.cache.session-cache-size</span>=<span class="string">5</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果更愿意使用本地的池,可以通过向 <code>org.messaginghub:pooled-jms</code> 添加依赖,并配置 <code>JmsPoolConnectionFactory</code> 来实现,如下例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.artemis.pool.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.artemis.pool.max-connections</span>=<span class="string">50</span></span><br></pre></td></tr></tbody></table></figure>

<p>有关更多支持的选项,请参阅<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/artemis/ArtemisProperties.java"><code>ArtemisProperties</code></a>.</p>
<p>不涉及 JNDI 查找,并且根据其名称解析destination, 使用 Artemis 配置中的 <code>name</code> 属性或通过配置提供的名称.</p>
</li>
<li><h6 id="使用-JNDI-连接工厂-Using-a-JNDI-ConnectionFactory"><a href="#使用-JNDI-连接工厂-Using-a-JNDI-ConnectionFactory" class="headerlink" title="使用 JNDI 连接工厂(Using a JNDI ConnectionFactory)"></a>使用 JNDI 连接工厂(Using a JNDI ConnectionFactory)</h6><p>如果在应用程序服务器中运行应用,Spring Boot 会尝试使用 JNDI 来定位 JMS <code>ConnectionFactory</code>.默认情况下,会检查 <code>java:/JmsXA</code> 和 <code>java:/XAConnectionFactory</code> 位置. 如果需要指定路径,可以使用 <code>spring.jms.jndi-name</code> 属性,如下例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.jms.jndi-name</span>=<span class="string">java:/MyConnectionFactory</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="发送消息-Sending-a-Message"><a href="#发送消息-Sending-a-Message" class="headerlink" title="发送消息(Sending a Message)"></a>发送消息(Sending a Message)</h6><p>Spring 的 <code>JmsTemplate</code> 是自动配置的,可以将其直接autowire到自己的 bean 中,如下例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(JmsTemplate jmsTemplate)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.jmsTemplate = jmsTemplate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    <code>JmsMessagingTemplate</code> 可以以类似的方式注入. 如果定义了 <code>DestinationResolver</code> 或 <code>MessageConverter</code> bean,它会自动关联到自动配置的 <code>JmsTemplate</code>.</p>
</blockquote>
</li>
<li><h6 id="接收消息-Receiving-a-Message"><a href="#接收消息-Receiving-a-Message" class="headerlink" title="接收消息(Receiving a Message)"></a>接收消息(Receiving a Message)</h6></li>
</ol>
</li>
</ol>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;当 JMS infrastructure存在时,任何 bean 都可以使用 <code>@JmsListener</code> 进行标注以创建监听器端点.如果没有定义 <code>JmsListenerContainerFactory</code>,则会自动配置默认值. 如果定义了 <code>DestinationResolver</code>,<code>MessageConverter</code> 或 <code>javax.jms.ExceptionListener</code> bean,它们将自动与默认工厂关联.</p>
<pre><code>  默认情况下,默认工厂是事务性的. 如果infrastructure 中存在 `JtaTransactionManager` ,则默认情况下它会被关联到监听器容器.如果没有,则启用 `sessionTransacted` 标志. 在后一种情况下,可以通过在监听器方法(或其委托)上添加 `@Transactional` 将本地数据存储事务关联到对传入消息的处理上来.这可确保在本地事务完成后,acknowledge传入消息.这还包括发送响应消息,消息是已在同一 JMS 会话上执行的.

  以下组件在 `someQueue` 目标上创建一个监听器端点:

  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener(destination = "someQueue")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>{</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

  &gt;建议:
  &gt;
  &gt;​    有关更多详细信息,请参阅 `@EnableJms的Javadoc`([the Javadoc of `@EnableJms`](https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/jms/annotation/EnableJms.html).)

  如果需要创建更多 `JmsListenerContainerFactory` 实例或者如果想覆盖默认值,Spring Boot 提供了一个 `DefaultJmsListenerContainerFactoryConfigurer`,可以使用它来初始化 `DefaultJmsListenerContainerFactory` ,其设置与自动配置的设置相同.

  例如,以下示例暴露了另一个使用特定 `MessageConverter` 的工厂:

  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJmsConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultJmsListenerContainerFactory <span class="title">myFactory</span><span class="params">(DefaultJmsListenerContainerFactoryConfigurer configurer)</span> </span>{</span><br><span class="line">        DefaultJmsListenerContainerFactory factory = <span class="keyword">new</span> DefaultJmsListenerContainerFactory();</span><br><span class="line">        ConnectionFactory connectionFactory = getCustomConnectionFactory();</span><br><span class="line">        configurer.configure(factory, connectionFactory);</span><br><span class="line">        factory.setMessageConverter(<span class="keyword">new</span> MyMessageConverter());</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ConnectionFactory <span class="title">getCustomConnectionFactory</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

  然后可以在任何 `@JmsListener` 注释的方法中使用工厂,如下所示:

  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener(destination = "someQueue", containerFactory = "myFactory")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>{</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</code></pre>
<ol start="2">
<li><h6 id="AMQP-高级消息队列协议"><a href="#AMQP-高级消息队列协议" class="headerlink" title="AMQP(高级消息队列协议)"></a>AMQP(高级消息队列协议)</h6><p>高级消息队列协议 (AMQP) 是面向消息中间件的平台中立的线级协议.Spring AMQP 项目将核心 Spring 概念应用于基于 AMQP 的消息传递方案的开发.Spring Boot 为通过 RabbitMQ 使用 AMQP 提供了多种便利的方式,包括 <code>spring-boot-starter-amqp</code> “Starter”.</p>
<ol>
<li><h6 id="RabbitMQ-支持-RabbitMQ-support"><a href="#RabbitMQ-支持-RabbitMQ-support" class="headerlink" title="RabbitMQ 支持 (RabbitMQ support)"></a>RabbitMQ 支持 (RabbitMQ support)</h6><p>RabbitMQ 是一个基于 AMQP 协议的轻量级,可靠,可扩展和可移植的消息代理. Spring 使用 <code>RabbitMQ</code> 通过 AMQP 协议进行通信.</p>
<p>RabbitMQ 配置由 <code>spring.rabbitmq.*</code> 中的外部配置属性控制.例如,可以在 <code>application.properties</code> 中声明以下部分:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">secret</span></span><br></pre></td></tr></tbody></table></figure>

<p>或者,可以使用 <code>address</code> 属性配置相同的连接:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.addresses</span>=<span class="string">amqp://admin:secret@localhost</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    以这种方式指定地址时,主机和端口属性将被忽略. 如果地址使用 <code>amqps</code> 协议,则自动启用 SSL 支持.</p>
</blockquote>
<p>有关更多受支持的基于属性的配置选项,参阅 RabbitProperties(<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitProperties.java"><code>RabbitProperties</code></a>).要配置 Spring AMQP 使用的 RabbitMQ <code>ConnectionFactory</code> 的低级详细信息,定义 <code>ConnectionFactoryCustomizer</code> bean.</p>
<p>如果context中存在 <code>ConnectionNameStrategy</code> bean,它将自动用于命名由自动配置的 <code>CachingConnectionFactory</code> 创建的连接.</p>
<blockquote>
<p>建议:</p>
<p>​    有关更多详细信息,请参阅了解 RabbitMQ 使用的协议 AMQP( <a target="_blank" rel="noopener" href="https://spring.io/blog/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/">Understanding AMQP, the protocol used by RabbitMQ</a>).</p>
</blockquote>
</li>
<li><h6 id="发送消息-Sending-a-Message-1"><a href="#发送消息-Sending-a-Message-1" class="headerlink" title="发送消息(Sending a Message)"></a>发送消息(Sending a Message)</h6><p>Spring 的 <code>AmqpTemplate</code> 和 <code>AmqpAdmin</code> 是自动配置的,可以将它们直接自动装配到自己的 bean 中,如下例所示 :</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AmqpAdmin amqpAdmin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(AmqpAdmin amqpAdmin, AmqpTemplate amqpTemplate)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.amqpAdmin = amqpAdmin;</span><br><span class="line">        <span class="keyword">this</span>.amqpTemplate = amqpTemplate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    <code>RabbitMessagingTemplate</code> 可以以类似的方式注入. 如果定义了 <code>MessageConverter</code> bean,它会自动关联到自动配置的 <code>AmqpTemplate</code>.</p>
</blockquote>
<p>如有必要,任何定义为 bean 的 <code>org.springframework.amqp.core.Queue</code> 都会自动用于在 RabbitMQ 实例上声明相应的队列.</p>
<p>要重试操作,可以在 <code>AmqpTemplate</code> 上启用重试(例如,在broker连接丢失的情况下):</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.template.retry.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.retry.initial-interval</span>=<span class="string">2s</span></span><br></pre></td></tr></tbody></table></figure>

<p>默认情况下禁用重试. 还可以通过声明 <code>RabbitRetryTemplateCustomizer</code> bean 以编程方式自定义 <code>RetryTemplate</code>.</p>
<p>如果需要创建更多 <code>RabbitTemplate</code> 实例或者如果想覆盖默认值,Spring Boot 提供了一个 <code>RabbitTemplateConfigurer</code> bean,可以使用它来初始化 <code>RabbitTemplate</code>,其设置与自动配置使用的工厂相同.</p>
</li>
<li><h6 id="接受消息-Receiving-a-Message"><a href="#接受消息-Receiving-a-Message" class="headerlink" title="接受消息(Receiving a Message)"></a>接受消息(Receiving a Message)</h6><p>当存在 Rabbit infrastructure时,任何 bean 都可以被 <code>@RabbitListener </code>标注以创建监听器端点.如果未定义 <code>RabbitListenerContainerFactory</code>,则会自动配置默认的 <code>SimpleRabbitListenerContainerFactory</code>,可以使用 <code>spring.rabbitmq.listener.type</code> 属性切换到直接容器.如果定义了 <code>MessageConverter</code> 或 <code>MessageRecoverer</code> bean,它会自动与默认工厂相关联.</p>
<p>以下示例组件在 <code>someQueue</code> 队列上创建一个监听器端点:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = "someQueue")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>{</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    有关更多详细信息,请参阅 <code>@EnableRabbit</code>的<code>Javadoc</code>(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-amqp/docs/2.3.7/api/org/springframework/amqp/rabbit/annotation/EnableRabbit.html">the Javadoc of <code>@EnableRabbit</code></a>).</p>
</blockquote>
<p>如果需要创建更多 <code>RabbitListenerContainerFactory</code> 实例或者如果想覆盖默认值,Spring Boot 提供了 <code>SimpleRabbitListenerContainerFactoryConfigurer</code> 和 <code>DirectRabbitListenerContainerFactoryConfigurer</code> 可用于初始化 <code>SimpleRabbitListenerContainerFactory</code> 和 <code>DirectRabbitListenerContainerFactory</code> ,其设置与自动配置使用的工厂相同.</p>
<blockquote>
<p>建议:</p>
<p>​    选择哪种容器类型并不重要. 这两个 bean 由自动配置公开.</p>
</blockquote>
<p>例如,以下配置类公开了另一个使用特定 <code>MessageConverter</code> 的工厂:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRabbitConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">myFactory</span><span class="params">(SimpleRabbitListenerContainerFactoryConfigurer configurer)</span> </span>{</span><br><span class="line">        SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">        ConnectionFactory connectionFactory = getCustomConnectionFactory();</span><br><span class="line">        configurer.configure(factory, connectionFactory);</span><br><span class="line">        factory.setMessageConverter(<span class="keyword">new</span> MyMessageConverter());</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ConnectionFactory <span class="title">getCustomConnectionFactory</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后就可以在任何<code>@RabbitListener</code>标注方法中使用工厂了,如下:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{ublic <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = "someQueue", containerFactory = "myFactory")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>{</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以启用重试来处理监听器抛出异常的情况. 默认使用 <code>RejectAndDontRequeueRecoverer</code>,但可以定义自己的 <code>MessageRecoverer</code>.当重试次数用尽时,如果代理配置为此,消息将被拒绝并被丢弃或路由到死信交换.默认情况下,重试被禁用. 可以通过声明 <code>RabbitRetryTemplateCustomizer</code> bean 以编程方式自定义 <code>RetryTemplate</code>.</p>
<blockquote>
<p>重要:</p>
<p>​    默认情况下,如果禁用重试并且listener抛出异常,则将无限重试发送.可以通过两种方式修改此行为:将 <code>defaultRequeueRejected</code> 属性设置为 <code>false</code> 以便尝试零重新发送或抛出 <code>AmqpRejectAndDontRequeueException</code> 以表示应拒绝消息.后者是启用重试并达到最大传递尝试次数时使用的机制.</p>
</blockquote>
</li>
</ol>
</li>
<li><h6 id="Apache-Kafka-支持-Apache-Kafka-Support"><a href="#Apache-Kafka-支持-Apache-Kafka-Support" class="headerlink" title="Apache Kafka 支持(Apache Kafka Support)"></a>Apache Kafka 支持(Apache Kafka Support)</h6><p>通过提供 spring-kafka 项目的自动配置来支持 Apache Kafka.</p>
<p>Kafka 配置由 <code>spring.kafka.*</code> 中的外部配置属性控制. 例如,可以在 <code>application.properties</code> 中声明以下部分:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.kafka.bootstrap-servers</span>=<span class="string">localhost:9092</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.group-id</span>=<span class="string">myGroup</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    要在启动时创建topic,请添加 <code>NewTopic</code> 类型的 bean. 如果主题已存在,则忽略该 bean.</p>
</blockquote>
<p>有关更多支持的选项,请参阅 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/kafka/KafkaProperties.java"><code>KafkaProperties</code></a>.</p>
<ol>
<li><h6 id="发送消息-Sending-a-Message-2"><a href="#发送消息-Sending-a-Message-2" class="headerlink" title="发送消息 (Sending a Message)"></a>发送消息 (Sending a Message)</h6><p>Spring 的 <code>KafkaTemplate</code> 是自动配置的,可以直接在自己的 bean 中自动装配,如下例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(KafkaTemplate&lt;String, String&gt; kafkaTemplate)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.kafkaTemplate = kafkaTemplate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    如果定义了 <code>spring.kafka.producer.transaction-id-prefix</code> 属性,则会自动配置一个 <code>KafkaTransactionManager</code>.此外,如果定义了 <code>RecordMessageConverter</code> bean,它会自动关联到自动配置的 <code>KafkaTemplate</code>.</p>
</blockquote>
</li>
<li><h6 id="接受消息-Receiving-a-Message-1"><a href="#接受消息-Receiving-a-Message-1" class="headerlink" title="接受消息(Receiving a Message)"></a>接受消息(Receiving a Message)</h6><p>当存在 Apache Kafka infrastructure 时,任何 bean 都可以使用 <code>@KafkaListener</code> 进行标注以创建listener endpoint.如果未定义 <code>KafkaListenerContainerFactory</code>,则默认使用 <code>spring.kafka.listener.*</code> 中定义的键进行自动配置.</p>
<p>以下组件在 <code>someTopic</code> 主题上创建一个listener endpoint:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = "someTopic")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>{</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果定义了 <code>KafkaTransactionManager</code> bean,它会自动关联到容器工厂.同样,如果定义了 <code>RecordFilterStrategy</code>,<code>ErrorHandler</code>,<code>AfterRollbackProcessor</code> 或 <code>ConsumerAwareRebalanceListener</code> bean,它会自动关联到默认工厂.</p>
<p>根据listener类型,将 <code>RecordMessageConverter</code> 或 <code>BatchMessageConverter</code> bean 关联到默认工厂.如果只有<code>RecordMessageConverter</code> bean用于批监听器,则它被包装在 <code>BatchMessageConverter</code> 中.</p>
<blockquote>
<p>建议:</p>
<p>​    自定义 <code>ChainedKafkaTransactionManager</code> 必须标记为 <code>@Primary</code>,因为它通常引用自动配置的 <code>KafkaTransactionManager</code> bean.</p>
</blockquote>
</li>
<li><h6 id="Kafka-Streams"><a href="#Kafka-Streams" class="headerlink" title="Kafka Streams"></a>Kafka Streams</h6><p>Spring for Apache Kafka 提供了一个工厂 bean 来创建一个 <code>StreamsBuilder</code> 对象并管理流的生命周期.只要 <code>kafka-streams</code> 在classpath上并且使用 <code>@EnableKafkaStreams</code> 注解启用了 <code>Kafka Streams</code>,Spring Boot 就会自动配置所需的 <code>KafkaStreamsConfiguration</code> bean.</p>
<p>启用 Kafka Streams 意味着必须设置应用程序 ID 和引导服务器.前者可以使用 <code>spring.kafka.streams.application-id</code> 配置,如果没有设置默认为 <code>spring.application.name</code>. 后者可以全局设置或仅针对流专门覆盖.</p>
<p>使用专用属性可以使用多个附加属性.可以使用 <code>spring.kafka.streams.properties</code> 命名空间设置其他任意 Kafka 属性.另参阅其他 Kafka 属性以获取更多信息.(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.messaging.kafka.additional-properties">Additional Kafka Properties</a>).</p>
<p>要使用工厂 bean,将 <code>StreamsBuilder</code> 连接到 <code>@Bean</code> 中,如下例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableKafkaStreams</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyKafkaStreamsConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KStream&lt;Integer, String&gt; <span class="title">kStream</span><span class="params">(StreamsBuilder streamsBuilder)</span> </span>{</span><br><span class="line">        KStream&lt;Integer, String&gt; stream = streamsBuilder.stream(<span class="string">"ks1In"</span>);</span><br><span class="line">        stream.map(<span class="keyword">this</span>::uppercaseValue).to(<span class="string">"ks1Out"</span>, Produced.with(Serdes.Integer(), <span class="keyword">new</span> JsonSerde&lt;&gt;()));</span><br><span class="line">        <span class="keyword">return</span> stream;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> KeyValue&lt;Integer, String&gt; <span class="title">uppercaseValue</span><span class="params">(Integer key, String value)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KeyValue&lt;&gt;(key, value.toUpperCase());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>默认情况下,由 <code>StreamBuilder</code> 对象管理的流会自动启动.可以使用 <code>spring.kafka.streams.auto-startup</code> 属性自定义此行为.</p>
</li>
<li><h6 id="其他-Kafka-属性-Additional-Kafka-Properties"><a href="#其他-Kafka-属性-Additional-Kafka-Properties" class="headerlink" title="其他 Kafka 属性 (Additional Kafka Properties)"></a>其他 Kafka 属性 (Additional Kafka Properties)</h6><p>自动配置支持的属性显示在<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/application-properties.html#application-properties">application-properties.html</a> 中. 注意,在大多数情况下,这些属性(连字符或驼峰命名)直接映射到 Apache Kafka 虚线属性.有关详细信息,请参阅 Apache Kafka 文档.</p>
<p>这些属性中的前几个适用于所有组件(生产者,消费者,管理员和流),但如果希望使用不同的值,可以在组件级别指定.Apache Kafka 指定使用高,中或低重要性来指定属性.Spring Boot 自动配置支持所有 HIGH 重要性属性,一些特定的 MEDIUM 和 LOW 属性,以及任何没有默认值的属性.</p>
<p>只有 Kafka 支持属性的一个子集可以直接通过 <code>KafkaProperties</code> 类获得.如果希望使用那些没有直接支持的其他属性,来配置生产者或消费者,使用以下属性:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.kafka.properties[prop.one]</span>=<span class="string">first</span></span><br><span class="line"><span class="meta">spring.kafka.admin.properties[prop.two]</span>=<span class="string">second</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.properties[prop.three]</span>=<span class="string">third</span></span><br><span class="line"><span class="meta">spring.kafka.producer.properties[prop.four]</span>=<span class="string">fourth</span></span><br><span class="line"><span class="meta">spring.kafka.streams.properties[prop.five]</span>=<span class="string">fifth</span></span><br></pre></td></tr></tbody></table></figure>

<p>这将共通的 <code>prop.one</code> Kafka 属性设置为 <code>first</code>(适用于生产者,消费者和管理员),<code>prop.two admin</code> 属性设置为<code>second</code>,<code>prop.three</code>消费者属性设置为<code>third</code>,<code>prop.four</code> 生产者属性设置为<code>prop.four</code>和 <code>prop .five</code> 流属性为<code>fifth</code>.</p>
<p>还可以按如下方式配置 Spring Kafka <code>JsonDeserializer</code>:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.kafka.consumer.value-deserializer</span>=<span class="string">org.springframework.kafka.support.serializer.JsonDeserializer</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.properties[spring.json.value.default.type]</span>=<span class="string">com.example.Invoice</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.properties[spring.json.trusted.packages]</span>=<span class="string">com.example.main,com.example.another</span></span><br></pre></td></tr></tbody></table></figure>

<p>同样,可以禁用在header中发送类型信息的 <code>JsonSerializer</code> 默认行为:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.kafka.producer.value-serializer</span>=<span class="string">org.springframework.kafka.support.serializer.JsonSerializer</span></span><br><span class="line"><span class="meta">spring.kafka.producer.properties[spring.json.add.type.headers]</span>=<span class="string">false</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>重要:</p>
<p>​    以这种方式设置的属性会覆盖 Spring Boot 显示支持的任何配置.</p>
</blockquote>
</li>
<li><h6 id="使用嵌入式-Kafka-进行测试-Testing-with-Embedded-Kafka"><a href="#使用嵌入式-Kafka-进行测试-Testing-with-Embedded-Kafka" class="headerlink" title="使用嵌入式 Kafka 进行测试 (Testing with Embedded Kafka)"></a>使用嵌入式 Kafka 进行测试 (Testing with Embedded Kafka)</h6><p>Spring 为 Apache Kafka 提供了一种使用嵌入式 Apache Kafka broker测试项目的便捷方法.要使用此功能,请使用 <code>spring-kafka-test</code> 模块中的 <code>@EmbeddedKafka</code> 注解来测试类.有关更多信息,请参阅 Spring for Apache Kafka 参考手册(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-kafka/docs/2.7.1/reference/html/#embedded-kafka-annotation">reference manual</a>).</p>
<p>要使 Spring Boot 自动配置与上述嵌入式 Apache Kafka broker一起工作,需要将嵌入式broker地址(由 <code>EmbeddedKafkaBroker</code> 填充)的系统属性重新映射到  Spring Boot为 Apache Kafka 设置的配置属性中.有几种方法可以做到这一点:</p>
<ul>
<li><p>提供一个系统属性将嵌入的broker地址映射到测试类中的 <code>spring.kafka.bootstrap-servers</code></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> {</span><br><span class="line">    System.setProperty(EmbeddedKafkaBroker.BROKER_LIST_PROPERTY, <span class="string">"spring.kafka.bootstrap-servers"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>在<code>@EmbeddedKafka</code> 注解上配置属性名:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@EmbeddedKafka(topics = "someTopic", bootstrapServersProperty = "spring.kafka.bootstrap-servers")</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>在配置属性中使用占位符:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.kafka.bootstrap-servers</span>=<span class="string">${spring.embedded.kafka.brokers}</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/54951.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/54951.html" class="post-title-link" itemprop="url">第十五篇,Spring Boot之缓存</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-04 12:45:00 / 修改时间：13:06:22" itemprop="dateCreated datePublished" datetime="2021-06-04T12:45:00+08:00">2021-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/54951.html" class="post-meta-item leancloud_visitors" data-flag-title="第十五篇,Spring Boot之缓存" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="13-缓存-Caching"><a href="#13-缓存-Caching" class="headerlink" title="13 缓存(Caching)"></a>13 缓存(Caching)</h5><ol start="13">
<li><h5 id="缓存-Caching"><a href="#缓存-Caching" class="headerlink" title="缓存(Caching)"></a>缓存(Caching)</h5><p>Spring Framework 支持透明地向应用程序添加缓存. 在其核心,抽象上,对方法使用缓存,从而根据缓存中可用的信息,减少执行次数.缓存逻辑是透明化应用的,对调用者没有任何干扰. 只要通过<code>@EnableCaching</code> 注释启用缓存支持,Spring Boot 就会自动配置缓存基础结构.</p>
<blockquote>
<p>注意:</p>
<p>​    查看 Spring Framework 参考的相关部分(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/integration.html#cache">relevant section</a>)以获取更多详细信息.</p>
</blockquote>
<p>简而言之,要将缓存添加到服务的操作中,在其方法中添加相关的注解,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMathService</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable("piDecimals")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computePiDecimal</span><span class="params">(<span class="keyword">int</span> precision)</span> </span>{</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此示例演示了对潜在代价高昂的操作使用缓存.在调用 <code>computePiDecimal</code> 之前,抽象会在 <code>piDecimals</code> 缓存中查找与 <code>i</code> 参数匹配的条目. 如果找到一个条目,缓存中的内容会立即返回给调用者,并且不会调用该方法. 否则,调用该方法,并在返回值之前更新缓存.</p>
<blockquote>
<p>警告:</p>
<p>​    还可以透明地使用标准 JSR-107 (JCache) 注释(例如 <code>@CacheResult</code>). 但是,强烈建议不要混合搭配 Spring Cache 和 JCache 注释.</p>
</blockquote>
<p>如果不添加任何特定的缓存库,Spring Boot 会自动配置一个在内存中使用concurrent  Map的简单provider.当需要缓存时(例如前面示例中的 <code>piDecimals</code>),provider会创建它.不建议将 simple provider 用于生产用途,但它非常适合入门并帮助了解这些功能.当决定要使用的缓存provider时,务必阅读其文档以了解如何配置应用所用的缓存.几乎所有provider都要求在应用中显式配置使用的每个缓存. 有些提供了一种自定义由 <code>spring.cache.cache-names</code> 属性定义的默认缓存的方法.  </p>
<blockquote>
<p>建议:</p>
<p>​    还可以从缓存中透明地更新或驱逐数据(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/integration.html#cache-annotations-put">update</a> or <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/integration.html#cache-annotations-evict">evict</a>).</p>
</blockquote>
<ol>
<li><h6 id="支持的缓存Provider-Supported-Cache-Providers"><a href="#支持的缓存Provider-Supported-Cache-Providers" class="headerlink" title="支持的缓存Provider(Supported Cache Providers)"></a>支持的缓存Provider(Supported Cache Providers)</h6><p>缓存抽象不提供实际存储,并且依赖于 <code>org.springframework.cache.Cache</code> 和 <code>org.springframework.cache.CacheManager</code> 接口具体化的抽象.</p>
<p>如果尚未定义 <code>CacheManager</code> 类型的 bean 或名为 <code>cacheResolver</code> 的 <code>CacheResolver</code>(参阅 <code>CachingConfigurer</code>),Spring Boot 会尝试检测以下提供程序(按指示的顺序):</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.generic">Generic</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.jcache">JCache (JSR-107)</a> (EhCache 3, Hazelcast, Infinispan, 和其他)</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.ehcache2">EhCache 2.x</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.hazelcast">Hazelcast</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.infinispan">Infinispan</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.couchbase">Couchbase</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.redis">Redis</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.caffeine">Caffeine</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.simple">Simple</a></li>
</ol>
<blockquote>
<p>建议:</p>
<p>​    也可以通过设置 <code>spring.cache.type</code> 属性来<strong>强制</strong>特定的cache provider.如果需要在某些环境(例如测试)中完全禁用缓存(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.none">disable caching altogether</a>),请使用此属性.</p>
<p>建议:</p>
<p>​    使用 <code>spring-boot-starter-cache</code> “Starter” 快速添加基本缓存依赖.starter 引入了 <code>spring-context-support</code>.如果手动添加依赖项,则必须包含 <code>spring-context-support</code> 才能使用 JCache,EhCache 2.x 或 Caffeine 支持.</p>
</blockquote>
<p>如果 <code>CacheManager</code> 是由 Spring Boot 自动配置的,可以在它完全初始化之前通过公开实现 <code>CacheManagerCustomizer</code> 接口的 bean 进一步调整其配置.以下示例设置了一个标志,表示应将<code>null</code>传递给底层映射:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCacheManagerConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManagerCustomizer&lt;ConcurrentMapCacheManager&gt; <span class="title">cacheManagerCustomizer</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (cacheManager) -&gt; cacheManager.setAllowNullValues(<span class="keyword">false</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    在前面的示例中,需要一个自动配置的 <code>ConcurrentMapCacheManager</code>. 如果不是这种情况(提供了自己的配置或自动配置了不同的缓存provider),则根本不会调用自定义程序. 可以根据需要,使用任意数量的customizers,也可以使用 <code>@Order</code> 或 <code>Ordered</code> 对它们进行排序.</p>
</blockquote>
<ol>
<li><h6 id="通用-Generic"><a href="#通用-Generic" class="headerlink" title="通用(Generic)"></a>通用(Generic)</h6><p>如果上下文<em><strong>至少</strong></em>定义了一个 <code>org.springframework.cache.Cache</code> bean,则使用通用缓存.创建了一个包装所有该类型 bean 的 <code>CacheManager</code>.</p>
</li>
<li><h6 id="JCache-JSR-107"><a href="#JCache-JSR-107" class="headerlink" title="JCache (JSR-107)"></a>JCache (JSR-107)</h6><p>JCache 通过classpath存在的 <code>javax.cache.spi.CachingProvider</code> 进行引导(即classpath上存在符合 JSR-107 的缓存库),而 <code>JCacheCacheManager</code> 由 <code>spring-boot-starter-cache</code> 提供 “Starter”.各种兼容库都可用,Spring Boot 为 Ehcache3,Hazelcast 和 Infinispan 提供依赖管理.也可以添加任何其他兼容的库.</p>
<p>可能会出现多个provider,在这种情况下,必须显式指定provider.即使 JSR-107 标准没有强制使用标准化的方式来指定配置文件的位置,Spring Boot 也会尽量设置缓存和实现细节,如下面的例子所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Only necessary if more than one provider is present</span></span><br><span class="line"><span class="meta">spring.cache.jcache.provider</span>=<span class="string">com.example.MyCachingProvider</span></span><br><span class="line"><span class="meta">spring.cache.jcache.config</span>=<span class="string">classpath:example.xml</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    当缓存库同时提供本地实现和 JSR-107支持时,Spring Boot 首选JSR-107 支持,以便在切换到不同的 JSR-107 实现时可以使用相同的功能.</p>
<p>建议:</p>
<p>​    Spring Boot 支持 Hazelcast.如果有一个<code>HazelcastInstance</code>可用,则它也会自动为 <code>CacheManager</code> 重用,除非指定了<code>spring.cache.jcache.config</code>属性</p>
</blockquote>
<p>有两种方式来自定义底层的<code>javax.cache.cacheManager</code>:</p>
<ul>
<li>可以通过设置 <code>spring.cache.cache-names</code> 属性在启动时创建缓存. 如果自定义了<code>javax.cache.configuration.Configuration</code> bean,则用于自定义属性.</li>
<li>使用 <code>CacheManager</code>的引用来调用<code>org.springframework.boot.autoconfigure.cache.JCacheManagerCustomizer</code> bean 从而进行完全自定义.</li>
</ul>
<blockquote>
<p>建议:</p>
<p>​    如果定义了标准 <code>javax.cache.CacheManager</code> bean,会在<code>org.springframework.cache.CacheManager</code>实现(抽象所期望的)中自动包装,. 不会对其应用进一步的自定义.</p>
</blockquote>
</li>
<li><h6 id="EhCache-2-x"><a href="#EhCache-2-x" class="headerlink" title="EhCache 2.x"></a>EhCache 2.x</h6><p>如果可以在classpath的根目录找到名为<code>ehcache.xml</code>的文件,则使用 EhCache 2.x. 如果找到 EhCache 2.x,则使用 <code>spring-boot-starter-cache</code> “Starter” 提供的 <code>EhCacheCacheManager</code> 来引导缓存管理器.也可以提供备用配置文件,如以下示例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cache.ehcache.config</span>=<span class="string">classpath:config/another-config.xml</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Hazelcast"><a href="#Hazelcast" class="headerlink" title="Hazelcast"></a>Hazelcast</h6><p>Spring Boot 支持 Hazelcast. 如果 <code>HazelcastInstance</code> 已自动配置,则它会自动包装在 <code>CacheManager</code> 中.</p>
</li>
<li><h6 id="Infinispan"><a href="#Infinispan" class="headerlink" title="Infinispan"></a>Infinispan</h6><p>Infinispan 没有默认配置文件位置,因此必须显式指定. 否则,使用默认引导程序:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cache.infinispan.config</span>=<span class="string">infinispan.xml</span></span><br></pre></td></tr></tbody></table></figure>

<p>可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建缓存.如果自定义了 <code>ConfigurationBuilder</code> bean,它将用于自定义缓存.</p>
<blockquote>
<p>建议:</p>
<p>​    Spring Boot 对 Infinispan 的支持仅限于嵌入式模式,并且非常基础.如果想要更多的选择,应该使用官方的 Infinispan Spring Boot starter. 有关更多详细信息,请参阅 Infinispan(<a target="_blank" rel="noopener" href="https://github.com/infinispan/infinispan-spring-boot">Infinispan’s documentation</a>) 的文档.</p>
</blockquote>
</li>
<li><h6 id="Couchbase"><a href="#Couchbase" class="headerlink" title="Couchbase"></a>Couchbase</h6><p>如果 Spring Data Couchbase 可用并且配置了 Couchbase,则<code>CouchbaseCacheManager</code>会自动配置.可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建额外的缓存,并且可以使用 <code>spring.cache.couchbase.*</code> 属性配置缓存默认值.例如,以下配置创建 <code>cache1</code> 和 <code>cache2</code> 缓存,条目过期时间为 10 分钟:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cache.cache-names</span>=<span class="string">cache1,cache2</span></span><br><span class="line"><span class="meta">spring.cache.couchbase.expiration</span>=<span class="string">10m</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果需要对配置进行更多控制,请考虑注册 <code>CouchbaseCacheManagerBuilderCustomizer</code> bean.以下示例显示了为 <code>cache1</code> 和 <code>cache2</code> 配置特定条目到期时间的customizer:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCouchbaseCacheManagerConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CouchbaseCacheManagerBuilderCustomizer <span class="title">myCouchbaseCacheManagerBuilderCustomizer</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (builder) -&gt; builder</span><br><span class="line">                .withCacheConfiguration(<span class="string">"cache1"</span>, CouchbaseCacheConfiguration</span><br><span class="line">                        .defaultCacheConfig().entryExpiry(Duration.ofSeconds(<span class="number">10</span>)))</span><br><span class="line">                .withCacheConfiguration(<span class="string">"cache2"</span>, CouchbaseCacheConfiguration</span><br><span class="line">                        .defaultCacheConfig().entryExpiry(Duration.ofMinutes(<span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h6><p>如果 Redis 可用并已配置,则自动配置 <code>RedisCacheManager</code>. 如果想要在启动时添加额外缓存, 可以设置<code>spring.cache.cache-names</code>属性,并且可以使用 <code>spring.cache.redis.*</code> 属性配置缓存默认值.例如,以下配置创建 <code>cache1</code> 和 <code>cache2</code> 缓存,生存时间为 10 分钟:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cache.cache-names</span>=<span class="string">cache1,cache2</span></span><br><span class="line"><span class="meta">spring.cache.redis.time-to-live</span>=<span class="string">10m</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    默认情况下,添加了一个key前缀,这样,如果两个单独的缓存使用相同的key,Redis 不会有重叠的键,也不会返回无效值.如果创建自己的 <code>RedisCacheManager</code>,我们强烈建议您启用此设置.</p>
<p>建议:</p>
<p>​    可以通过添加自己的 <code>RedisCacheConfiguration</code> <code>@Bean</code> 来完全控制默认配置.如果自定义默认序列化策略,这会很有.</p>
</blockquote>
<p>如果需要对配置进行更多控制,可以考虑注册一个 <code>RedisCacheManagerBuilderCustomizer</code> bean.以下示例显示了为 <code>cache1</code> 和 <code>cache2</code> 配置特定生存时间的customizer:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRedisCacheManagerConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisCacheManagerBuilderCustomizer <span class="title">myRedisCacheManagerBuilderCustomizer</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (builder) -&gt; builder</span><br><span class="line">                .withCacheConfiguration(<span class="string">"cache1"</span>, RedisCacheConfiguration</span><br><span class="line">                        .defaultCacheConfig().entryTtl(Duration.ofSeconds(<span class="number">10</span>)))</span><br><span class="line">                .withCacheConfiguration(<span class="string">"cache2"</span>, RedisCacheConfiguration</span><br><span class="line">                        .defaultCacheConfig().entryTtl(Duration.ofMinutes(<span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Caffeine"><a href="#Caffeine" class="headerlink" title="Caffeine"></a>Caffeine</h6><p>Caffeine 是对 Guava 缓存的 Java 8 重写,取代了对 Guava 的支持.如果存在 Caffeine,则会自动配置 <code>CaffeineCacheManager</code>(由 <code>spring-boot-starter-cache</code> “Starter”提供). 可以通过设置 <code>spring.cache.cache-names</code> 属性, 在启动时创建缓存,并且可以通过以下之一(按指示的顺序)进行自定义:</p>
<ol>
<li>使用 <code>spring.cache.caffeine.spec</code> 定义的缓存规范</li>
<li>定义 <code>com.github.benmanes.caffeine.cache.CaffeineSpec</code> bean</li>
<li>定义 <code>com.github.benmanes.caffeine.cache.Caffeine</code> bean</li>
</ol>
<p>例如,以下配置创建 <code>cache1</code> 和 <code>cache2</code> 缓存,最大大小为 500,生存时间为 10 分钟:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cache.cache-names</span>=<span class="string">cache1,cache2</span></span><br><span class="line"><span class="meta">spring.cache.caffeine.spec</span>=<span class="string">maximumSize=500,expireAfterAccess=600s</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果定义了 <code>com.github.benmanes.caffeine.cache.CacheLoader</code> bean,它会自动关联到 <code>CaffeineCacheManager</code>. 由于 <code>CacheLoader</code> 将与缓存管理器管理的<em><strong>所有</strong></em>缓存相关联,因此必须将其定义为 <code>CacheLoader&lt;Object, Object&gt;</code>. 自动配置忽略任何其他通用类型.</p>
</li>
<li><h6 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h6><p>如果找不到其他providers,则指定 <code>ConcurrentHashMap</code> 作为缓存存储.如果应用程序中不存在缓存库,则这是默认设置.默认情况下,会根据需要创建缓存,但可以通过设置 <code>cache-names</code> 属性来限制可用缓存的列表.例如,如果只想要 <code>cache1</code> 和 <code>cache2</code> 缓存,设置 <code>cache-names</code> 属性如下:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cache.cache-names</span>=<span class="string">cache1,cache2</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果这样做,并且应用使用了未列出的缓存,那么在使用缓存而缓存不存在时,会运行时失败,但不会在启动时失败.如果使用未声明的缓存,这类似于”真实”缓存providers的行为方式.</p>
</li>
<li><h6 id="None"><a href="#None" class="headerlink" title="None"></a>None</h6><p>当配置中存在 <code>@EnableCaching</code> 时,也需要合适的缓存配置.如果需要在某些环境中完全禁用缓存,可以将缓存类型强制为 <code>none</code> 以使用无操作实现,如下例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cache.type</span>=<span class="string">none</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  © 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chenyk</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">174k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:38</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>


  





  
  

  
  <script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


  
  


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.1.0/dist/quicklink.umd.js"></script>
  
  



<script src="/bundle.js"></script><script>{&quot;enable&quot;:true,&quot;spinner&quot;:true};
{&quot;enable&quot;:true,&quot;app_id&quot;:null,&quot;app_key&quot;:null,&quot;server_url&quot;:null,&quot;security&quot;:true};
{&quot;enable&quot;:true,&quot;home&quot;:true,&quot;archive&quot;:true,&quot;delay&quot;:true,&quot;timeout&quot;:3000,&quot;priority&quot;:true,&quot;ignores&quot;:null,&quot;url&quot;:&quot;http:&#x2F;&#x2F;example.com&#x2F;&quot;}</script></body></html>